<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fanlu.top</id>
    <title>何妨吟啸且徐行 • Posts by &#34;前端搬砖指南&#34; tag</title>
    <link href="https://fanlu.top" />
    <updated>2023-05-16T00:19:08.000Z</updated>
    <category term="golang实验室" />
    <category term="前端搬砖指南" />
    <category term="云服务器" />
    <category term="工具" />
    <category term="鸡毛蒜皮周刊" />
    <entry>
        <id>https://fanlu.top/2023/05/16/vben-admin%E6%8D%A2%E8%82%A4%E5%AE%9E%E7%8E%B0/</id>
        <title>vben-admin换肤实现</title>
        <link rel="alternate" href="https://fanlu.top/2023/05/16/vben-admin%E6%8D%A2%E8%82%A4%E5%AE%9E%E7%8E%B0/"/>
        <content type="html">&lt;p&gt;最近在 github 上看到了一个后台管理的前端项目，使用了 vue3+ts+vite+ant-vue 的技术，看起来很不错，功能特别丰富，clone 下来发现代码也写的特别好，比我现在的小白代码根本不在同一个等级，因此想要学习一下。 个人觉得从一个功能抽丝剥茧来学习一个功能的写法可能会对自己的技术提高有帮助。&lt;/p&gt;
&lt;p&gt;项目中的侧边栏提供了超多的主题选项，可以丰富的变换主题。因此本文想分析一下这个换肤是如何实现的。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://secure2.wostatic.cn/static/wGUf6UvBJUZVXfAPhrzaF/image.png?auth_key=1684196309-2jkBMzvREcZ21xSJjxnEvU-0-4173f6dd779469091bae7835b4c93aa7&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;黑色亮色主题切换&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#黑色亮色主题切换&#34;&gt;#&lt;/a&gt; 黑色 / 亮色主题切换&lt;/h2&gt;
&lt;p&gt;主题切换组件 AppDarkModeToggle.vue&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义点击事件 toggleDarkMode
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;调用设置黑色主题函数 setDarkMode&lt;/p&gt;
&lt;p&gt;修改 pinia 状态中的 dark 模式，并将变量存储到 localStorage 中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用 updateDarkTheme&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取 htmlRoot dom 节点，即本项目应用的根节点&lt;/li&gt;
&lt;li&gt;判断根节点是否包含 dark class 定义&lt;/li&gt;
&lt;li&gt;如果是 dark
&lt;ul&gt;
&lt;li&gt;判断是否为生产模式，并加载 dark 主题 css（由 vite-plugin-theme 支持）&lt;/li&gt;
&lt;li&gt;将根节点的 data-teme 设置为 dark&lt;/li&gt;
&lt;li&gt;并添加 class 为 dark&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果不是 dark
&lt;ul&gt;
&lt;li&gt;将根节点 data-theme 设置为 light&lt;/li&gt;
&lt;li&gt;并且移除 dark class&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;这里修改data-theme为dark，利用了less中条件判断语句
例如：

  html[data-theme=&#39;dark&#39;] &amp;#123;
    .@&amp;#123;prefix-cls&amp;#125; &amp;#123;
      border: 1px solid rgb(196 188 188);
    &amp;#125;
  &amp;#125;

ps：less还支持动态变量名，6666
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;3. 调用updateHeaderBgColor修改header的背景色
    - 判断是否为dark模式，获取到颜色，如果不是暗色，那就获取当前设置的颜色
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;color = appStore.getHeaderSetting.bgColor;&lt;br&gt;
- 将获取到的颜色设置 css 变量  setCssVar&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;export function setCssVar(prop: string, val: any, dom = docEle) &amp;#123;
  console.log(prop,val)
  dom.style.setProperty(prop, val);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    - 计算得到hover颜色（亮度提高6），同样设置css变量

        这里用到了自定义的颜色函数，我觉得很有用
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;/**
 * 判断是否 十六进制颜色值.
 * 输入形式可为 #fff000 #f00
 *
 * @param   String  color   十六进制颜色值
 * @return  Boolean
 */
export function isHexColor(color: string) &amp;#123;
  const reg = /^#([0-9a-fA-F]&amp;#123;3&amp;#125;|[0-9a-fA-f]&amp;#123;6&amp;#125;)$/;
  return reg.test(color);
&amp;#125;

/**
 * RGB 颜色值转换为 十六进制颜色值.
 * r, g, 和 b 需要在 [0, 255] 范围内
 *
 * @return  String          类似#ff00ff
 * @param r
 * @param g
 * @param b
 */
export function rgbToHex(r: number, g: number, b: number) &amp;#123;
  // tslint:disable-next-line:no-bitwise
  const hex = ((r &amp;lt;&amp;lt; 16) | (g &amp;lt;&amp;lt; 8) | b).toString(16);
  return &#39;#&#39; + new Array(Math.abs(hex.length - 7)).join(&#39;0&#39;) + hex;
&amp;#125;

/**
 * Transform a HEX color to its RGB representation
 * @param &amp;#123;string&amp;#125; hex The color to transform
 * @returns The RGB representation of the passed color
 */
export function hexToRGB(hex: string) &amp;#123;
  let sHex = hex.toLowerCase();
  if (isHexColor(hex)) &amp;#123;
    if (sHex.length === 4) &amp;#123;
      let sColorNew = &#39;#&#39;;
      for (let i = 1; i &amp;lt; 4; i += 1) &amp;#123;
        sColorNew += sHex.slice(i, i + 1).concat(sHex.slice(i, i + 1));
      &amp;#125;
      sHex = sColorNew;
    &amp;#125;
    const sColorChange: number[] = [];
    for (let i = 1; i &amp;lt; 7; i += 2) &amp;#123;
      sColorChange.push(parseInt(&#39;0x&#39; + sHex.slice(i, i + 2)));
    &amp;#125;
    return &#39;RGB(&#39; + sColorChange.join(&#39;,&#39;) + &#39;)&#39;;
  &amp;#125;
  return sHex;
&amp;#125;

export function colorIsDark(color: string) &amp;#123;
  if (!isHexColor(color)) return;
  const [r, g, b] = hexToRGB(color)
    .replace(/(?:\(|\)|rgb|RGB)*/g, &#39;&#39;)
    .split(&#39;,&#39;)
    .map((item) =&amp;gt; Number(item));
  return r * 0.299 + g * 0.578 + b * 0.114 &amp;lt; 192;
&amp;#125;

/**
 * Darkens a HEX color given the passed percentage
 * @param &amp;#123;string&amp;#125; color The color to process
 * @param &amp;#123;number&amp;#125; amount The amount to change the color by
 * @returns &amp;#123;string&amp;#125; The HEX representation of the processed color
 */
export function darken(color: string, amount: number) &amp;#123;
  color = color.indexOf(&#39;#&#39;) &amp;gt;= 0 ? color.substring(1, color.length) : color;
  amount = Math.trunc((255 * amount) / 100);
  return `#$&amp;#123;subtractLight(color.substring(0, 2), amount)&amp;#125;$&amp;#123;subtractLight(
    color.substring(2, 4),
    amount,
  )&amp;#125;$&amp;#123;subtractLight(color.substring(4, 6), amount)&amp;#125;`;
&amp;#125;

/**
 * Lightens a 6 char HEX color according to the passed percentage
 * @param &amp;#123;string&amp;#125; color The color to change
 * @param &amp;#123;number&amp;#125; amount The amount to change the color by
 * @returns &amp;#123;string&amp;#125; The processed color represented as HEX
 */
export function lighten(color: string, amount: number) &amp;#123;
  color = color.indexOf(&#39;#&#39;) &amp;gt;= 0 ? color.substring(1, color.length) : color;
  amount = Math.trunc((255 * amount) / 100);
  return `#$&amp;#123;addLight(color.substring(0, 2), amount)&amp;#125;$&amp;#123;addLight(
    color.substring(2, 4),
    amount,
  )&amp;#125;$&amp;#123;addLight(color.substring(4, 6), amount)&amp;#125;`;
&amp;#125;

/* Suma el porcentaje indicado a un color (RR, GG o BB) hexadecimal para aclararlo */
/**
 * Sums the passed percentage to the R, G or B of a HEX color
 * @param &amp;#123;string&amp;#125; color The color to change
 * @param &amp;#123;number&amp;#125; amount The amount to change the color by
 * @returns &amp;#123;string&amp;#125; The processed part of the color
 */
function addLight(color: string, amount: number) &amp;#123;
  const cc = parseInt(color, 16) + amount;
  const c = cc &amp;gt; 255 ? 255 : cc;
  return c.toString(16).length &amp;gt; 1 ? c.toString(16) : `0$&amp;#123;c.toString(16)&amp;#125;`;
&amp;#125;

/**
 * Calculates luminance of an rgb color
 * @param &amp;#123;number&amp;#125; r red
 * @param &amp;#123;number&amp;#125; g green
 * @param &amp;#123;number&amp;#125; b blue
 */
function luminanace(r: number, g: number, b: number) &amp;#123;
  const a = [r, g, b].map((v) =&amp;gt; &amp;#123;
    v /= 255;
    return v &amp;lt;= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  &amp;#125;);
  return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;
&amp;#125;

/**
 * Calculates contrast between two rgb colors
 * @param &amp;#123;string&amp;#125; rgb1 rgb color 1
 * @param &amp;#123;string&amp;#125; rgb2 rgb color 2
 */
function contrast(rgb1: string[], rgb2: number[]) &amp;#123;
  return (
    (luminanace(~~rgb1[0], ~~rgb1[1], ~~rgb1[2]) + 0.05) /
    (luminanace(rgb2[0], rgb2[1], rgb2[2]) + 0.05)
  );
&amp;#125;

/**
 * Determines what the best text color is (black or white) based con the contrast with the background
 * @param hexColor - Last selected color by the user
 */
export function calculateBestTextColor(hexColor: string) &amp;#123;
  const rgbColor = hexToRGB(hexColor.substring(1));
  const contrastWithBlack = contrast(rgbColor.split(&#39;,&#39;), [0, 0, 0]);

  return contrastWithBlack &amp;gt;= 12 ? &#39;#000000&#39; : &#39;#FFFFFF&#39;;
&amp;#125;

/**
 * Subtracts the indicated percentage to the R, G or B of a HEX color
 * @param &amp;#123;string&amp;#125; color The color to change
 * @param &amp;#123;number&amp;#125; amount The amount to change the color by
 * @returns &amp;#123;string&amp;#125; The processed part of the color
 */
function subtractLight(color: string, amount: number) &amp;#123;
  const cc = parseInt(color, 16) - amount;
  const c = cc &amp;lt; 0 ? 0 : cc;
  return c.toString(16).length &amp;gt; 1 ? c.toString(16) : `0$&amp;#123;c.toString(16)&amp;#125;`;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    - updateSidebarBgColor  修改侧边栏颜色 原理同上
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上大概有几个关键点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;充分利用 less 的用法
&lt;ul&gt;
&lt;li&gt;条件语句&lt;/li&gt;
&lt;li&gt;动态前缀变量名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;利用 js 来修改原生 css 变量的颜色，同时计算悬浮颜色&lt;/li&gt;
&lt;li&gt;项目中大部分样式类名以前缀方式定义，主 less 中定义了一个 vben 为 namespace，在 less 中作为全局变量；而 designSetting 中定义了 prefixCls 在 ts 中作为全局变量。 他们存在这对应关系，因此需要同时修改才能起作用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;导航栏模式切换&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#导航栏模式切换&#34;&gt;#&lt;/a&gt; 导航栏模式切换&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;导航栏模式分为了四种：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;https://secure2.wostatic.cn/static/sPjnd9xQ7suquNPauh5Qqw/image.png?auth_key=1684196309-2o96KrtYmowc5t254R8edZ-0-bbe91f85e3201ce1060d94391f94427b&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左边可折叠菜单，右边上部面包屑，下部内容&lt;/li&gt;
&lt;li&gt;上下布局，上部面包屑，下面左边菜单右边内容&lt;/li&gt;
&lt;li&gt;上下布局，上面菜单，下面内容&lt;/li&gt;
&lt;li&gt;左右布局，左边菜单点击展开子目录，右上方面包屑，下方内容&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;右边的样式选项都是通过自定义的 Picker 组件来实现的，导航栏模式选择的是 TypePicker 组件，传入的方法是 baseHandler:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Vue&#34;&gt; &amp;lt;TypePicker
    menuTypeList=&amp;#123;menuTypeList&amp;#125;
    handler=&amp;#123;(item: typeof menuTypeList[0]) =&amp;gt; &amp;#123;
      baseHandler(HandlerEnum.CHANGE_LAYOUT, &amp;#123;
        mode: item.mode,
        type: item.type,
        split: unref(getIsHorizontal) ? false : undefined,
      &amp;#125;);
    &amp;#125;&amp;#125;
    def=&amp;#123;unref(getMenuType)&amp;#125;
  /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 menuTypeList 表示上方提到的四种模式，其定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export const menuTypeList = [
  &amp;#123;
    title: t(&#39;layout.setting.menuTypeSidebar&#39;),
    mode: MenuModeEnum.INLINE,
    type: MenuTypeEnum.SIDEBAR,
  &amp;#125;,
  &amp;#123;
    title: t(&#39;layout.setting.menuTypeMix&#39;),
    mode: MenuModeEnum.INLINE,
    type: MenuTypeEnum.MIX,
  &amp;#125;,

  &amp;#123;
    title: t(&#39;layout.setting.menuTypeTopMenu&#39;),
    mode: MenuModeEnum.HORIZONTAL,
    type: MenuTypeEnum.TOP_MENU,
  &amp;#125;,
  &amp;#123;
    title: t(&#39;layout.setting.menuTypeMixSidebar&#39;),
    mode: MenuModeEnum.INLINE,
    type: MenuTypeEnum.MIX_SIDEBAR,
  &amp;#125;,
];
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;ps: 由样式定义来看，less 支持不同状态下，class 后面拼接字符串的样式，比如 &amp;amp;–active&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;调用 handler 函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取 appStore 配置信息&lt;/li&gt;
&lt;li&gt;根据传来的 mode 和 type 生成新的 menuSetting&lt;/li&gt;
&lt;li&gt;将新的配置更新到 pinia 全局配置中&lt;/li&gt;
&lt;li&gt;更新来的配置几乎每一个属性都封装为一个 computed&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export interface MenuSetting &amp;#123;
  bgColor: string;
  fixed: boolean;
  collapsed: boolean;
  siderHidden: boolean;
  canDrag: boolean;
  show: boolean;
  hidden: boolean;
  split: boolean;
  menuWidth: number;
  mode: MenuModeEnum;
  type: MenuTypeEnum;
  theme: ThemeEnum;
  topMenuAlign: &#39;start&#39; | &#39;center&#39; | &#39;end&#39;;
  trigger: TriggerEnum;
  accordion: boolean;
  closeMixSidebarOnChange: boolean;
  collapsedShowTitle: boolean;
  mixSideTrigger: MixSidebarTriggerEnum;
  mixSideFixed: boolean;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全都定义在 useMenuSetting.ts 中，这是一个&lt;strong&gt;自定义 hook&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;系统主题切换&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#系统主题切换&#34;&gt;#&lt;/a&gt; 系统主题切换&lt;/h2&gt;
&lt;p&gt;自定义组件 ThemeColorPicker 实现，包含三个 prop&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;颜色列表&lt;/li&gt;
&lt;li&gt;默认颜色 通过 getThemeColor 计算属性获取（真实来源自 pinia 中存储的 themeColor）** 默认值都配置在 src/projectSetting.ts 下面 **&lt;/li&gt;
&lt;li&gt;event，表示事件 ID&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过点击事件，调用 baseHandle 修改全局配置；&lt;/p&gt;
&lt;p&gt;调用 generateColors 方法生成一组颜色，这组颜色的计算可以参考：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-TypeScript&#34;&gt;export function generateColors(&amp;#123;
  color = primaryColor,
  mixLighten,
  mixDarken,
  tinycolor,
&amp;#125;: GenerateColorsParams) &amp;#123;
  const arr = new Array(19).fill(0);
  const lightens = arr.map((_t, i) =&amp;gt; &amp;#123;
    return mixLighten(color, i / 5);
  &amp;#125;);

  const darkens = arr.map((_t, i) =&amp;gt; &amp;#123;
    return mixDarken(color, i / 5);
  &amp;#125;);

  const alphaColors = arr.map((_t, i) =&amp;gt; &amp;#123;
    return tinycolor(color)
      .setAlpha(i / 20)
      .toRgbString();
  &amp;#125;);

  const shortAlphaColors = alphaColors.map((item) =&amp;gt; item.replace(/\s/g, &#39;&#39;).replace(/0\./g, &#39;.&#39;));

  const tinycolorLightens = arr
    .map((_t, i) =&amp;gt; &amp;#123;
      return tinycolor(color)
        .lighten(i * 5)
        .toHexString();
    &amp;#125;)
    .filter((item) =&amp;gt; item !== &#39;#ffffff&#39;);

  const tinycolorDarkens = arr
    .map((_t, i) =&amp;gt; &amp;#123;
      return tinycolor(color)
        .darken(i * 5)
        .toHexString();
    &amp;#125;)
    .filter((item) =&amp;gt; item !== &#39;#000000&#39;);
  return [
    ...lightens,
    ...darkens,
    ...alphaColors,
    ...shortAlphaColors,
    ...tinycolorDarkens,
    ...tinycolorLightens,
  ].filter((item) =&amp;gt; !item.includes(&#39;-&#39;));
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后利用 vite-plugin-theme 方法替换样式变量&lt;/p&gt;
&lt;h2 id=&#34;顶栏主题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#顶栏主题&#34;&gt;#&lt;/a&gt; 顶栏主题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;自定义组件 ThemeColorPicker&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用 updateHeaderBgColor 方法&lt;/p&gt;
&lt;p&gt;首先判断是否为夜间模式，夜间模式不生效；&lt;/p&gt;
&lt;p&gt;然后修改 css 变量–header-bg-color&lt;/p&gt;
&lt;p&gt;修改悬浮颜色： const hoverColor = lighten (color!, 6); 修改 css 变量&lt;/p&gt;
&lt;p&gt;修改 headerSetting： 判断选择的颜色是否属于暗色，然后结合当前是否为暗色模式，判断设置是否生效&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;菜单主题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#菜单主题&#34;&gt;#&lt;/a&gt; 菜单主题&lt;/h2&gt;
&lt;p&gt;同顶栏主题&lt;/p&gt;
&lt;h2 id=&#34;最后&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#最后&#34;&gt;#&lt;/a&gt; 最后&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;vben 这个项目比较大，功能可以说是非常丰富，也可以说时非常冗杂，想要啃下来非常困难。 看到一个博客专门分析 vben 的可以参考：&lt;/p&gt;
&lt;/blockquote&gt;
</content>
        <category term="前端搬砖指南" />
        <updated>2023-05-16T00:19:08.000Z</updated>
    </entry>
</feed>
